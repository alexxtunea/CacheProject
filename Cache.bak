module Cache#(
     parameter CACHE_SIZE = 32768; //32 KB
     parameter BLOCK_SIZE = 64; //64 bytes for each block
     parameter NO_SETS = 128; //numarul de seturi 
     parameter CACHE_TYPE = 4; // 4 way associativity
     parameter WORD_SIZE = 4; //each word has 4 bytes 
)(
     input clk, rst,
     input [31:0] address, data_to_write,
     input read, write,
     output reg [31:0] read_data,
     output reg hit, miss, free
);

parameter NO_BLOCKS = BLOCK_SIZE / WORD_SIZE;
parameter INDEX_BITS = $clog2(NO_SETS);
parameter OFFSET_BITS = $clog2(BLOCK_SIZE);
parameter TAG_BITS = 32 - (INDEX_BITS + OFFSET_BITS);

reg [31:0] data_cache[NO_SETS-1:0][CACHE_TYPE-1:0][BLOCK_SIZE/4-1:0];
reg [TAG_BITS-1:0] tags_cache = [NO_SETS-1:0][CACHE_TYPE-1:0];
reg valid[NO_SETS-1:0][CACHE_TYPE-1:0];
reg [1:0] lru[NO_SETS-1:0][CACHE_TYPE-1:0];
reg dirty_bits[NO_SETS-1:0][CACHE_TYPE-1:0];

reg [INDEX_BITS- 1:0] index;
reg [OFFSET_BITS-1:0] offset;
reg [TAG_BITS-1:0] tag;
integer i, j, way_set;

parameter IDLE = 3'b000;
parameter READ = 3'b001;
parameter WRITE = 3'b010;
parameter READ_HIT = 3'b011;
parameter READ_MISS = 3'b100;
parameter WRITE_HIT = 3'b101;
parameter WRITE_MISS = 3'b110;
parameter EVICT = 3'b111;

reg [1:0] st, st_next;
reg ok;

always @(posedge clk or posedge rst) begin
        if (rst) begin
            st <= IDLE;
            for (i = 0; i < NO_SETS; i = i + 1) begin
                for (j = 0; j < CACHE_TYPE; j = j + 1) begin
                    valid[i][j] <= 0;
                    dirty_bits[i][j] <= 0;
                    lru[i][j] <= 0;
                end
            end
        end else begin
            st <= st_next;
        end
end

always @(*) begin
	case(st)
		IDLE: begin
			if(read) st_next = READ
			else if (write) st_next = WRITE;
			else	st_next = IDLE;
		end
		READ: begin
			index = address[OFFSET_BITS + INDEX_BITS - 1 : OFFSET_BITS];
			tag = address[31 : 32 - TAG_BITS];
			ok = 0;
                    	for (i = 0; i < CACHE_TYPE; i = i + 1) begin
                            if (valid[index][i] && tags_cache[index][i] == tag) begin
				ok = 1;
                                way_set = i;
                                break;
                            end
                        end
			if(ok == 1) st_next = READ_HIT;
			else st_next = READ_MISS;
		end
		WRITE: begin
			index = address[OFFSET_BITS + INDEX_BITS - 1 : OFFSET_BITS];
			tag = address[31 : 32 - TAG_BITS];
			ok = 0;
                    	for (i = 0; i < CACHE_TYPE; i = i + 1) begin
                            if (valid[index][i] && tags_cache[index][i] == tag) begin
				ok = 1;
                                way_set = i;
                                break;
                            end
                        end
			if(ok == 1) st_next = WRITE_HIT;
			else st_next = WRITE_MISS;
		end
	endcase
end



endmodule